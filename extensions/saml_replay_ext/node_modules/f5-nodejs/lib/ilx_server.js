/*jshint node:true*/
'use strict';

var events = require('events');
var net = require('net');
var util = require('util');

var ILXRequest = require('./ilx_request.js');
var ILXResponse = require('./ilx_response.js');

var ILXServerWrap = null;

/**
 * Represents a "multiplex" ILX server that accepts multiple messages over the same TCP connection.
 *
 * Expected message format: <length:UInt32BE><json_rpc_string:string>
 *
 * @constructor
 * @augments net.Server
 * @param {object} [methods] - hash of methods in {name: callback} format (optional)
 * @param {object} [options] - server options (optional)
 * @param {boolean} [options.debug=false] - debug logging
 * @param {integer} [options.timeout=5000] - TCP socket timeout in milliseconds
 */
function ILXServer(methods, options)
{
    if (ILXServerWrap !== null) {
        throw new Error('ILX server interface has already been initialized');
    }
    ILXServerWrap = process.binding('ILXServerWrap').ILXServerWrap;
    this._ilxServer = new ILXServerWrap();
    this._ilxServer.owner = this;

    // callbacks that are invoked from the C++ ILXServerWrap class
    this._ilxServer.onmessage = ilxServerMessageCallback;
    this._ilxServer.writable = ilxConfiguredCallback;

    options = options || {};
    options.debug = options.debug || false;
    options.timeout = options.timeout || 5000;
    this._options = options;

    this._defaultMethod = false;
    this._methods = methods || {};

    this._traceLevel = 0;
}
util.inherits(ILXServer, events.EventEmitter);

/**
 * Add a method handler.
 *
 * @param {string} name - method name
 * @param {ILXServer~methodCallback} callback that handles the request
 */
ILXServer.prototype.addMethod = function (name, callback)
{
    this._methods[name] = callback;
};

/**
 * Remove a method handler.
 *
 * @param {string} name - method name
 */
ILXServer.prototype.removeMethod = function (name)
{
    delete this._methods[name];
};

/**
 * Set a default handler for when no other method is available.
 *
 * @param {ILXServer~methodCallback} callback - callback that handles the request
 */
ILXServer.prototype.setDefaultMethod = function (callback)
{
    this._defaultMethod = callback;
};

/**
 * Listen to connections.
 *
 * @override
 * @param {int} [port] - deprecated
 */
ILXServer.prototype.listen = function(port)
{
    this._ilxServer.start();

    if (this._options.debug) {
        console.log('ILX RPC started');
    }
};

/**
 * Set the trace level for the server.
 *
 * @param {integer} level - the higher the value the more tracing information will be generated
 */
ILXServer.prototype.setTraceLevel = function(level)
{
    this._traceLevel = level;
    this._ilxServer.setTraceLevel(level);
};

/**
 * Returns the trace level for the server.
 */
ILXServer.prototype.traceLevel = function()
{
    return this._traceLevel;
};

/**
 * Callback that delivers a message buffer from the tmm.
 *
 * @param {buffer} [msgBuf] - The message
 * @param {integer} [msgLen] - Length in bytes of the message
 * @param {integer} [requestId] - Unique request identifier
 */
function ilxServerMessageCallback(msgBuf, msgLen, requestId)
{
    var server = this;
    var self = server.owner;

    if (self._options.debug) {
        console.log("ILXServer: buffer, len (" + msgLen + ") requestId(" + requestId + ")");
        console.log(msgBuf.toString());
    }

    var parsedMsg;
    try {
        parsedMsg = JSON.parse(msgBuf.toString());
        if (!parsedMsg) {
            return;
        }
        if (self._options.debug) {
            console.log("JSON: " + util.inspect(parsedMsg));
        }
    }
    catch (err) {
        new ILXResponse(requestId, null, self._ilxServer).error('JSON parse error', -32700,
            { request: msgBuf.toString(), error: err.message });
        return;
    }

    if (parsedMsg.id) {
        if (parsedMsg.method && self._methods[parsedMsg.method]) {
            self._methods[parsedMsg.method](
                new ILXRequest(parsedMsg),
                new ILXResponse(requestId, parsedMsg.id, self._ilxServer));

        }
        else if (self._defaultMethod) {
            self._defaultMethod(
                new ILXRequest(parsedMsg),
                new ILXResponse(requestId, parsedMsg.id, self._ilxServer));

        }
        else {
            new ILXResponse(requestId, parsedMsg.id, self._ilxServer).error(
                'Method not found', -32601, { method: parsedMsg.method });
        }
    }
    else {
        // notifications get no response
        if (parsedMsg.method && self._methods[parsedMsg.method]) {
            self._methods[parsedMsg.method](new ILXRequest(parsedMsg));

        } else if (self._defaultMethod) {
            self._defaultMethod(new ILXRequest(parsedMsg));
        }
        else {
            console.error("ILX::notify method not found (" +
                parsedMsg.method + ") " + util.inspect(parsedMsg));
        }
    }
}

/**
 * The ILXServer#initialized event will be emitted when the server is fully configured and has
 * connected to the TMM. Once this event has been received the server may use the ILXDatagroup
 * API.
 *
 * @fires ILXServer#initialized
 */
function ilxConfiguredCallback()
{
    var server = this;
    var self = server.owner;

    self.emit("initialized");
}
/**
 * initialized event.
 * @event ILXServer#initialized
 */

/**
 * Callback function that handles an incoming request from the tmm.
 * @callback ILXServer~methodCallback
 * @param {ILXRequest} request  - request object
 * @param {ILXResponse} [response] - response object (not available for notifications)
 */

module.exports = ILXServer;
