/*jshint node:true*/
'use strict';

/**
 * This file contains wrappers for the datagroup command implementation.
 *
 * @param {string} datagroup - the fully qualified name of the datagroup. Eg. /Common/MyDatagroup
 *
 * Please see devcentral.f5.com for more detail.
 *
 * @constructor
 */
function ILXDatagroup(datagroup)
{
    this._handle = process.binding('ILXDatagroupWrap');

    if (!this._handle.exists(datagroup)) {
        throw "datagroup " + datagroup + " does not exist";
    }

    this._datagroup = datagroup;

    this.Options = module.exports.Options;
    this.Type = module.exports.Type;

    this._type = this._handle.getType(this._datagroup);
}
/**
 * Get the number of records in the datagroup
 */
ILXDatagroup.prototype.getSize = function()
{
    return this._handle.getSize(this._datagroup);
};

/**
 * Get the type of the datagroup (currently supported types (ILXDatagroup.Type.{IP, STRING, INTEGER}
 */
ILXDatagroup.prototype.getType = function()
{
    return this._type;
};

/**
 * Get the string name of the type of the datagroup (currently supported types "IP", "STRING", "INTEGER"}
 */
ILXDatagroup.prototype.getTypeStr = function()
{
    return { 1: "IP", 2: "STRING", 3: "INTEGER" }[this._type];
};

/**
 * Search the datagroup for a name (full match) and return value based on the return options
 *
 * @param {string} name - value to find
 * @param {object} options - [optional] options to use for the search
 * @param {number} options.return - [optional] return options
 *     ILXDatagroup.Options.NAME - return the found name
 *     ILXDatagroup.Options.VALUE - return the value corresponding to the given name
 *     ILXDatagroup.Options.ELEMENT - returns an object containing both name and value in a named properties
 *     default: none - the return value will be true if match found and false otherwise.
 * @param {boolean} options.all - [optional] return one or all found matches  (default: false)
 * @param (boolean} options.icase - [optional] true for case insensitive search and false otherwise (default: false)
 */
ILXDatagroup.prototype.matchEquals = function(name, options)
{
    if (options === undefined) {
        options = {};
    }
    else {
        for (var prop in options) {
            if (options.hasOwnProperty(prop)) {
                switch(prop) {
                    case "all":     // fall though
                    case "icase":   // fall though
                    case "return":  // fall though
                        break;

                    default:
                        throw new Error("invalid option: " + prop);
                }
            }
        }
    }

    return this._handle.matchEquals(this._datagroup, name, options.return, options.all,
        options.icase);
};

/**
 * Search the datagroup for a name (record startswith) and return value based on the return options
 *
 * @param {string} name - value to find
 * @param {object} options - [optional] options to use for the search
 * @param {number} options.return - [optional] return options
 *     ILXDatagroup.Options.NAME - return the found name
 *     ILXDatagroup.Options.VALUE - return the value corresponding to the given name
 *     ILXDatagroup.Options.ELEMENT - returns an object containing both name and value in a named properties
 *     default: none - the return value will be true if match found and false otherwise.
 * @param {boolean} options.all - [optional] return one or all found matches  (default: false)
 * @param (boolean} options.icase - [optional] true for case insensitive search and false otherwise (default: false)
 */
ILXDatagroup.prototype.matchStartsWith = function(name, options)
{
    if (options === undefined) {
        options = {};
    }
    else {
        for (var prop in options) {
            if (options.hasOwnProperty(prop)) {
                switch(prop) {
                    case "all":     // fall though
                    case "icase":   // fall though
                    case "return":  // fall though
                        break;

                    default:
                        throw new Error("invalid option: " + prop);
                }
            }
        }
    }

    return this._handle.matchStartsWith(this._datagroup, name, options.return, options.all,
        options.icase);
};

/**
 * Search the datagroup for a name (record endswith) and return value based on the return options
 *
 * @param {string} name - value to find
 * @param {object} options - [optional] options to use for the search
 * @param {number} options.return - [optional] return options
 *     ILXDatagroup.Options.NAME - return the found name
 *     ILXDatagroup.Options.VALUE - return the value corresponding to the given name
 *     ILXDatagroup.Options.ELEMENT - returns an object containing both name and value in a named properties
 *     default: none - the return value will be true if match found and false otherwise.
 * @param {boolean} options.all - [optional] return one or all found matches  (default: false)
 * @param (boolean} options.icase - [optional] true for case insensitive search and false otherwise (default: false)
 */
ILXDatagroup.prototype.matchEndsWith = function(name, options)
{
    if (options === undefined) {
        options = {};
    }
    else {
        for (var prop in options) {
            if (options.hasOwnProperty(prop)) {
                switch(prop) {
                    case "all":     // fall though
                    case "icase":   // fall though
                    case "return":  // fall though
                        break;

                    default:
                        throw new Error("invalid option: " + prop);
                }
            }
        }
    }

    return this._handle.matchEndsWith(this._datagroup, name, options.return, options.all,
        options.icase);
};

/**
 * Search the datagroup for a name (record contains) and return value based on the return options
 * @param {string} name - value to find
 * @param {object} options - [optional] options to use for the search
 * @param {number} options.return - [optional] return options
 *     ILXDatagroup.Options.NAME - return the found name
 *     ILXDatagroup.Options.VALUE - return the value corresponding to the given name
 *     ILXDatagroup.Options.ELEMENT - returns an object containing both name and value in a named properties
 *     default: none - the return value will be true if match found and false otherwise.
 * @param {boolean} options.all - [optional] return one or all found matches  (default: false)
 * @param (boolean} options.icase - [optional] true for case insensitive search and false otherwise (default: false)
 */
ILXDatagroup.prototype.matchContains = function(name, options)
{
    if (options === undefined) {
        options = {};
    }
    else {
        for (var prop in options) {
            if (options.hasOwnProperty(prop)) {
                switch(prop) {
                    case "all":     // fall though
                    case "icase":   // fall though
                    case "return":  // fall though
                        break;

                    default:
                        throw new Error("invalid option: " + prop);
                }
            }
        }
    }

    return this._handle.matchContains(this._datagroup, name, options.return, options.all,
        options.icase);
};

/**
 * Search the datagroup for a name (full match) and return value based on the return options
 * Note: searchEquals and matchEquals are completely the same
 *
 * @param {string} name - value to find
 * @param {object} options - [optional] options to use for the search
 * @param {number} options.return - [optional] return options
 *     ILXDatagroup.Options.NAME - return the found name
 *     ILXDatagroup.Options.VALUE - return the value corresponding to the given name
 *     ILXDatagroup.Options.ELEMENT - returns an object containing both name and value in a named properties
 *     default: none - the return value will be true if match found and false otherwise.
 * @param {boolean} options.all - [optional] return one or all found matches  (default: false)
 * @param (boolean} options.icase - [optional] true for case insensitive search and false otherwise (default: false)
 */
ILXDatagroup.prototype.searchEquals = function(name, options)
{
    if (options === undefined) {
        options = {};
    }
    else {
        for (var prop in options) {
            if (options.hasOwnProperty(prop)) {
                switch(prop) {
                    case "all":     // fall though
                    case "icase":   // fall though
                    case "return":  // fall though
                        break;

                    default:
                        throw new Error("invalid option: " + prop);
                }
            }
        }
    }

    return this._handle.matchEquals(this._datagroup, name, options.return, options.all,
        options.icase);
};

/**
 * Search the datagroup for a name (name startswith) and return value based on the return options
 *
 * @param {string} name - value to find
 * @param {object} options - [optional] options to use for the search
 * @param {number} options.return - [optional] return options
 *     ILXDatagroup.Options.NAME - return the found name
 *     ILXDatagroup.Options.VALUE - return the value corresponding to the given name
 *     ILXDatagroup.Options.ELEMENT - returns an object containing both name and value in a named properties
 *     default: none - the return value will be true if match found and false otherwise.
 * @param {boolean} options.all - [optional] return one or all found matches  (default: false)
 * @param (boolean} options.icase - [optional] true for case insensitive search and false otherwise (default: false)
 */
ILXDatagroup.prototype.searchStartsWith = function(name, options)
{
    if (options === undefined) {
        options = {};
    }
    else {
        for (var prop in options) {
            if (options.hasOwnProperty(prop)) {
                switch(prop) {
                    case "all":     // fall though
                    case "icase":   // fall though
                    case "return":  // fall though
                        break;

                    default:
                        throw new Error("invalid option: " + prop);
                }
            }
        }
    }

    return this._handle.searchStartsWith(this._datagroup, name, options.return, options.all,
        options.icase);
};

/**
 * Search the datagroup for a name (name endswith) and return value based on the return options
 *
 * @param {string} name - value to find
 * @param {object} options - [optional] options to use for the search
 * @param {number} options.return - [optional] return options
 *     ILXDatagroup.Options.NAME - return the found name
 *     ILXDatagroup.Options.VALUE - return the value corresponding to the given name
 *     ILXDatagroup.Options.ELEMENT - returns an object containing both name and value in a named properties
 *     default: none - the return value will be true if match found and false otherwise.
 * @param {boolean} options.all - [optional] return one or all found matches  (default: false)
 * @param (boolean} options.icase - [optional] true for case insensitive search and false otherwise (default: false)
 */
ILXDatagroup.prototype.searchEndsWith = function(name, options)
{
    if (options === undefined) {
        options = {};
    }
    else {
        for (var prop in options) {
            if (options.hasOwnProperty(prop)) {
                switch(prop) {
                    case "all":     // fall though
                    case "icase":   // fall though
                    case "return":  // fall though
                        break;

                    default:
                        throw new Error("invalid option: " + prop);
                }
            }
        }
    }

    return this._handle.searchEndsWith(this._datagroup, name, options.return, options.all,
        options.icase);
};

/**
 * Search the datagroup for a name (name contains) and return value based on the return options
 *
 * @param {string} name - value to find
 * @param {object} options - [optional] options to use for the search
 * @param {number} options.return - [optional] return options
 *     ILXDatagroup.Options.NAME - return the found name
 *     ILXDatagroup.Options.VALUE - return the value corresponding to the given name
 *     ILXDatagroup.Options.ELEMENT - returns an object containing both name and value in a named properties
 *     default: none - the return value will be true if match found and false otherwise.
 * @param {boolean} options.all - [optional] return one or all found matches  (default: false)
 * @param (boolean} options.icase - [optional] true for case insensitive search and false otherwise (default: false)
 */
ILXDatagroup.prototype.searchContains = function(name, options)
{
    if (options === undefined) {
        options = {};
    }
    else {
        for (var prop in options) {
            if (options.hasOwnProperty(prop)) {
                switch(prop) {
                    case "all":     // fall though
                    case "icase":   // fall though
                    case "return":  // fall though
                        break;

                    default:
                        throw new Error("invalid option: " + prop);
                }
            }
        }
    }

    return this._handle.searchContains(this._datagroup, name, options.return, options.all,
        options.icase);
};

/**
 * Iterate though every element in the datagroup and run a callback for each
 * of them, providing a read-only access to the element. If the callback
 * function returns True, the loop will be interrupted.
 *
 * Callbacks arguments:
 * @param {number} index - index of the current record. Eg. useful to limit the number of runs.,
 * @param {object} element - object containing both name and value of a record in datagroup.
 *      Eg. { name: <name>, value: <value}
 * @return {boolean} - if the return value is true, the loop will be interrupted after the current records.
 *      All other return values are ignored and the loop will continue up until the end.
 */
ILXDatagroup.prototype.forEach = function(cb)
{
    if (typeof cb !== 'function') {
        throw new Error("invalid option: " + cb + ", callback function was expected");
    }
    this._handle.forEach(this._datagroup, cb);
};

/**
 * Lookup a value for given key (equivalent for matchEquals command returning a single value)
 * @param {string} name - value to find
 */
ILXDatagroup.prototype.lookup = function(name)
{
    return this._handle.matchEquals(this._datagroup, name, this.Options.VALUE, false, false);
};

module.exports = ILXDatagroup;

/**
 * Datagroup query options
 */
module.exports.Options = {
    NAME    : 1,
    VALUE   : 2,
    ELEMENT : 3,
};

/**
 * Datagroup type
 */
module.exports.Type = {
    IP      : 1,
    STRING  : 2,
    INTEGER : 3,
};
