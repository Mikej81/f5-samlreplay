/*jshint node:true*/
'use strict';

var events = require('events');
var util = require('util');
var ILXListeners = require('./ilx_plugin_listeners');

/**
 * The ILXPluginServer class is similar in behavior to the node net.Server class. The server
 * listens for new connections.
 *
 * @constructor
 * @param {function} callback - Callback that will be invoked for a new connection. The socket
 *   for the connection is passed to the callback. The socket corresponds to an ILXFlow.client
 *   socket. The ILXFlow object associated with the socket is available to the callback in
 *   socket.f5.flow. This allows the server to act as a proxy between the client socket
 *   (ILXFlow.client) and the server socket socket.f5.flow.server (ILXFlow.server).
 */
function ILXPluginServer(callback)
{
    this._newConnectionCb = callback;
    this._disableServer = false;
}
util.inherits(ILXPluginServer, events.EventEmitter);

/**
 * Listen for new connections on the specified address and port. If the address or port is
 * omitted then the listener will accept connections for all addresses or ports. More specific
 * servers take precedence: addr:port, addr:*, *:port, *:*.
 * Omit the host or port options to listen on all addresses or ports.
 *
 * @constructor
 * @param {object} options - Listener configuration
 * @param {object} options.host - Optional IP address.
 * @param {object} options.port - Options IP port.
 * @param {object} options.disableServer - By default the ILXPluginServer is a proxy. The socket
 *   passed to the callback registered in the constructor contains the ILXFlow object sock.f5.flow.
 *   ILXFlow.client is passed to the callback. If the server will not use ILXFlow.server the
 *   disableServer option can be used to automatically close ILXFlow.server before the callback
 *   is invoked.
 * @param {function} listeningCallback - Callback that will be invoked when the listener has
 *   been successfully bound.
 */
ILXPluginServer.prototype.listen = function(options, listeningCallback)
{
    var self = this;
    var err;
    var cb;

    if (typeof options === "function") {
        // no options provided, listen on *:*
        cb = options;
        err = ILXListeners.add(this);
    }
    else {
        this._disableServer = options.disableServer;
        cb = listeningCallback;
        err = ILXListeners.add(this, options);
    }

    if (err === undefined) {
        process.nextTick(function() {
            self.emit("listening");
            if (cb !== undefined) {
                cb();
            }
        });
    }
    else {
        process.nextTick(function() {
            self.emit("error", err);
        });
    }
}

/**
 * A new connection has been received from the tmm. Invoked the servers new connection callback.
 * flow.client is passed to the callback.
 *
 * @param {object} flow - ILXFlow associated with the new client connection.
 */
ILXPluginServer.prototype.newFlow = function(flow)
{
    var self = this;

    if (this._disableServer === true) {
        flow.server.end();
    }

    // Handle all flow errors and propagate to the server if the plugin has not defined
    // handlers for flow, client or server
    flow.on("error", function(err) {
        if (flow.listeners("error").length === 1) {
            var msg = "flow error, " + err;
            self.emit("error", msg);
        }
    });
    flow.client.on("error", function(err) {
        if (flow.client.listeners("error").length === 1) {
            var msg = "client socket error, " + err;
            self.emit("error", msg);
        }
    });
    flow.server.on("error", function(err) {
        if (flow.server.listeners("error").length === 1) {
            var msg = "server socket error, " + err;
            self.emit("error", msg);
        }
    });

    // node makes the callback and then emits the connection event, in that order
    this._newConnectionCb(flow.client);
    this.emit('connection', flow.client);
}

/**
 * Closes the server. The server will no longer receive new connections.
 */
ILXPluginServer.prototype.close = function()
{
    ILXListeners.remove(this);

    // emit the close event
    var self = this;
    process.nextTick(function() {
        self.emit("close");
    });
}

/**
 * Returns an object that contains the address, port and address family associated with
 * the server { address: '10.1.1.1', port: 80, family: 'IPv4' }.
 */
ILXPluginServer.prototype.address = function()
{
    var family = undefined;
    if (this._address !== undefined) {
        // XXXX find js/node ip tools, will get the validator npm into our system
        if (this._address.indexOf(":") !== -1) {
            family = 'IPv6';
        }
        else {
            family = 'IPv4';
        }
    }

    return {
        address: this._address,
        port: this._port,
        family: family,
    };
}

module.exports = ILXPluginServer;
