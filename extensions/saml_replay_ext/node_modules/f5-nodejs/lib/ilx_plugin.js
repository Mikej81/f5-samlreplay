/*jshint node:true*/
'use strict';

var events = require('events');
var http = require('http');
var util = require('util');
var ILXFlow = require('./ilx_flow.js');
var ILXListeners = require('./ilx_plugin_listeners');
var ILXPluginOptions = require('./ilx_plugin_options.js');
var ILXStream = require('./ilx_stream.js');
ILXPlugin.prototype._instantiated = false;
var ILXPluginWrap = null;

/**
 * The ILXPlugin class is the entry point to the ILX Plugin feature. The ILXPlugin class manages
 * communication between the TMM and a Node.js plugin application.  The primary functions of the
 * ILXPlugin class are to a) configure initial communication settings, b) start the plugin server,
 * and c) provide a callback that is invoked when a new virtual server flow is created,
 * represented by the ILXFlow class.
 *
 * To start the plugin interface create an ILXPlugin object (at most one is allowed), setup
 * the 'clientConnected' event handler, configure ILXPlugin options and call
 * ILXPlugin.start(options). See ilx_flow.js for a description of events and methods on the
 * ILXFlow class.
 *
 * @constructor
 */
function ILXPlugin()
{
    var ILXServer = require('./ilx_server.js');

    if (ILXPluginWrap !== null) {
        throw new Error('ILX plugin interface has already been initialized');
    }

    events.EventEmitter.call(this);

    // lazy load
    ILXPluginWrap = process.binding('ILXPluginWrap').ILXPluginWrap;
    var ILXFlowWrap = process.binding('ILXFlowWrap').ILXFlowWrap;
    var ILXStreamWrap = process.binding('ILXStreamWrap').ILXStreamWrap;

    // link both ways, ILXPlugin knows the C++ ILXPluginWrap object, and the wrapper knows the
    // ILXPlugin object
    this._handle = new ILXPluginWrap();
    this._handle.owner = this;

    // callbacks that are invoked from the C++ ILXPluginWrap class
    this._handle.writable = ilxTmmConnectedCb;
    this._handle.onIlxClientConnected = ilxClientConnectedCb;

    // initializing datagroups interface
    this._datagroup = require('./ilx_datagroup.js');

    this._traceLevel = 0;

    this._httpServer = false;
    this._httpCallback = null;

    ILXPlugin.prototype._instantiated = true;
}
util.inherits(ILXPlugin, events.EventEmitter);

/**
 * Start the plugin.
 *
 * @param {object} options - ILXPluginOptions
 */
ILXPlugin.prototype.start = function(options)
{
    if (options === undefined) {
        options = new ILXPluginOptions();
    }
    this._handle.start(options);
    this._options = options;
};

/**
 * Start the plugin as a node.js http server. The callback function is the same as would be
 * passed to the node.js http.createServer(requestListener) method. Note that the event
 * ILXPlugin#connect will not be emitted for new client connections. Note that options.disableServer
 * and options.handleClientOpen are both enabled by default. This behavior can be overriden by
 * providing an ILXPluginOptions object. This function should not be used if there is an HTTP
 * profile on a Virtual Server that is associated with the plugin.
 *
 * @param {ILXPlugin~requestCallback} cb - Node.js HTTP request callback function.
 * @param {object} options - ILXPluginOptions
 */
ILXPlugin.prototype.startHttpServer = function(cb, options)
{
    if (typeof cb !== 'function') {
        throw new TypeError('Invalid argument: a callback function must be provided');
    }
    this.addListener('request', cb);

    if (options === undefined) {
        // this maintains backward compatibility with 13.0
        this._options = new ILXPluginOptions();
        this._options.handleClientOpen = true;
        this._options.disableServer = true;
    }
    else {
        this._options = options;
    }

    this._httpServer = true;
    this._handle.start(this._options);
};
/**
 * This callback is invoked when an HTTP request is received by the plugin when the plugin
 * has been started in HTTP server mode (ILXPlugin.startHttpServer). The request and response
 * objects are standard Node.js HTTP request and response objects.
 *
 * @callback ILXPlugin~requestCallback
 * @param {object} request
 * @param {object} response
 */
ILXPlugin.prototype._httpConnection = http._connectionListener;

/**
 * The ILXPlugin#initialized event will be emitted when the plugin has connected to the TMM.
 * Once this event has been received the plugin may receive virtual server flows (ILXFlow)
 * created outbound connections and session DB requests.
 * The ILXPlugin#uninitialized event will be emitted when the plugin is no longer associated with
 * a virtual server via an ILX profile.
 *
 * @fires ILXPlugin#initialized
 * @fires ILXPlugin#uninitialized
 */
function ilxTmmConnectedCb(pluginHandle, connected)
{
    var self = pluginHandle.owner;
    if (connected === true) {
        self.emit("initialized");
    }
    else {
        self.emit("uninitialized");
    }
}
/**
 * initialized event.
 * @event ILXPlugin#initialized
 */
/**
 * uninitialized event.
 * @event ILXPlugin#uninitialized
 */

/**
 * If the client stream matches an ILXPluginServer or ILXPluginHttpServer listener the stream
 * will be handed to the server object. If the plugin has been started using
 * ILXPlugin.startHttpServer the client stream will be handed to the native node.js HTTP
 * implementation and HTTP requests will be passed to the callback function given to
 * ILXPlugin.startHttpServer. The ILXPlugin#connect event will be emitted if the plugin has
 * been started using ILXPlugin.start. Note that only one of these actions will be taken.
 *
 * @fires ILXPlugin#connect
 */
function ilxClientConnectedCb(pluginHandle, flowHandle, clientStreamHandle, serverStreamHandle)
{
    var self = pluginHandle.owner;
    var flow = new ILXFlow(flowHandle, clientStreamHandle, serverStreamHandle);

    var listener = ILXListeners.get(flow.client.localAddress, flow.client.localPort);

    if (listener === undefined) {
        // There are no matching listeners. Deliver the connection to the ILXPlugin object if it
        // is listening on the connect event or was started as an HTTP server, otherwise end the
        // flow.
        if (self._httpServer === true) {
            if (self._options.disableServer) {
                flow.server.end();
            }
            self._httpConnection(flow.client);
        }
        else if (self.listeners('connect').length > 0) {
            if (self._options.disableServer) {
                flow.server.end();
            }
            self.emit("connect", flow);
        }
        else {
            flow.end();
        }
    }
    else {
        listener.newFlow(flow);
    }
}
/**
 * connect event.
 *
 * @event ILXPlugin#connect
 * @param {object} flow - ILXFlow
 */

/**
 * Set the trace level for the entire plugin. This will affect tracing for all ILXPlugin,
 * ILXFlow and ILXStream objects.
 *
 * @param {integer} level - the higher the value the more tracing information will be generated
 */
ILXPlugin.prototype.setGlobalTraceLevel = function(level)
{
    this._handle.setGlobalTraceLevel(level);
};

/**
 * Returns the global trace level.
 */
ILXPlugin.prototype.globalTraceLevel = function()
{
    return this._handle.getGlobalTraceLevel();
};

/**
 * Set the trace level for the plugin.
 *
 * @param {integer} level - the higher the value the more tracing information will be generated
 */
ILXPlugin.prototype.setTraceLevel = function(level)
{
    this._traceLevel = level;
    this._handle.setTraceLevel(level);
};

/**
 * Returns the trace level for the plugin.
 */
ILXPlugin.prototype.traceLevel = function()
{
    return this._traceLevel;
};

/**
 * Returns a datagroup object
 *
 * @param {string} datagroup - the fully qualified name of the datagroup. Eg. /Common/MyDatagroup
 */
ILXPlugin.prototype.getDataGroup = function(datagroup)
{
    return new this._datagroup(datagroup);
};

module.exports = ILXPlugin;
