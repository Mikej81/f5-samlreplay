/*jshint node:true*/
"use strict";

/**
 * The ILXBufferUtil Class provides F5 implemented commands to do common operations
 * on buffers, specifically including:
 * Search: Find matching bytes
 * Replace: Find and replace bytes
 * ReplaceAt: Replace some subsection with bytes
 * Insert: Insert new bytes
 * Append: Append bytes
 * Erase: Erase some subsection
 *
 * @constructor
 */
function ILXBufferUtil()
{
    this._handle = process.binding("ILXBufferUtil");
    this._handle.owner = this;
}

/**
 * Search for a byte sequence in the buffer.
 *
 * @param {buffer} buffer - source buffer
 * @param {string|buffer} bytes - byte sequence or string to search for
 * @param {object} options - [optional] search options
 * @param {number} options.offset - offset to start search from (0 == begining of the line)
 * @param {boolean} options.icase - if true - perform case insensitive search
 *
 * @return -1 or the idx found at
 */
ILXBufferUtil.prototype.search = function(buffer, bytes, options)
{
    if (buffer === undefined) {
        throw new Error("A buffer must be specified");
    }
    if (bytes === undefined) {
        throw new Error("A byte sequence must be specified");
    }

    options = options || {};

    if (options.offset === undefined) {
        options.offset = 0;
    }

    return this._handle.search(buffer, bytes, options.offset, options.icase);
};

/**
 * Search for a byte sequence in the buffer.
 *
 * @param {buffer} buffer - source buffer
 * @param {string|buffer} bytes - byte sequence or string to search for
 * @param {object} options - [optional] search options
 * @param {number} options.offset - offset to start search from
 *                                  (0 == begining of the line, -1 - end of the line)
 * @param {boolean} options.icase - if true - perform case insensitive search
 *
 * @return -1 or the idx found at
 */
ILXBufferUtil.prototype.rsearch = function(buffer, bytes, options)
{
    if (buffer === undefined) {
        throw new Error("A buffer must be specified");
    }
    if (bytes === undefined) {
        throw new Error("A byte sequence must be specified");
    }

    options = options || {};

    if (options.offset === undefined) {
        options.offset = -1;
    }

    return this._handle.rsearch(buffer, bytes, options.offset, options.icase);
};

/**
 * Search for and replace a byte sequence in the buffer, starting at offset.
 *
 * @param {buffer} buffer - source buffer
 * @param {string|buffer} old - byte sequence or string to replace
 * @param {string|buffer} repl - byte sequence of string to replace with
 * @param {objecT} result - the result object where to put the replace results to
 * @param {array} result.replaced - [out][read-only] after the function returns the list
 *                                  will contain the list of replaced tokens" indexes.
 *                                  If the result.replaced is empty - no matches were found.
 * @param {object} options - search options
 * @param {number} options.offset - [optional] offset to start search from
 * @param {boolean} options.all - [optional] if true - replace all matches. First one otherwise
 * @param {boolean} options.icase - [optional] if true - perform case insensitive search
*
 * @return {buffer} - new modified buffer with the replaced byte sequence(s).
 */
ILXBufferUtil.prototype.replace = function(buffer, old, repl, result, options)
{
    var curOffset, idx;

    if (buffer === undefined) {
        throw new Error("A buffer must be specified");
    }
    if (old === undefined) {
        throw new Error("An old byte sequence must be specified");
    }
    if (repl === undefined) {
        throw new Error("A replacement byte sequence must be specified");
    }

    result = result || {};
    result.replaced = [];

    options = options || {};

    if (options.offset === undefined) {
        options.offset = 0;
    }
    else if ((options.offset > (buffer.length - 1)) || (options.offset < 0)) {
        throw new Error("The offset is out of range (0 - " +
                        (buffer.length - 1) + ")");
    }

    curOffset = options.offset;
    do {
        idx = this.search(buffer, old, { offset: curOffset, icase: options.icase });
        if (idx < 0) {
            return buffer;  // not found
        }

        buffer = this.replaceAt(buffer, repl, idx, { length: old.length });
        curOffset = idx + repl.length;
        result.replaced.push(idx);
    } while (options.all && curOffset < buffer.length);

    return buffer;
};

/**
 * Replace an arbitrary subsection (from offset to offset+len) with
 *    a new byte sequence.
 *
 * @param {buffer} buffer - source buffer
 * @param {string|buffer} repl - byte sequence or string to replace
 * @param {number} offset - offset of the start position
 * @param {object} options - [optional] replace options
 * @param {number} options.length - length of the byte sequence to replace
 *                               if not specified defaults to end of buffer
 *
 * @return {buffer} new buffer with the replaced byte sequence.
 */
ILXBufferUtil.prototype.replaceAt = function(buffer, repl, offset, options)
{
    var newBuffer;

    if (buffer === undefined) {
        throw new Error("A buffer must be specified");
    }

    if (repl === undefined) {
        throw new Error("A new byte sequence must be specified");
    }

    if (offset === undefined) {
        throw new Error("An offset must be specified");
    }

    if ((offset > (buffer.length - 1)) || (offset < 0)) {
        throw new Error("An offset is out of range (0-" +
                        (buffer.length - 1) + ")");
    }

    options = options || {};

    if (options.length === undefined) {
        options.length = buffer.length - offset;
    }
    else {
        options.length = Math.min(buffer.length - offset, options.length);
    }

    newBuffer = new Buffer(buffer.length - options.length + repl.length);
    if (offset > 0) {
        buffer.copy(newBuffer, 0, 0, offset);
    }

    if (Buffer.isBuffer(repl)) {
        repl.copy(newBuffer, offset);
    }
    else {
        newBuffer.write(repl, offset, repl.length);
    }

    if ((offset + options.length) < buffer.length) {
        buffer.copy(newBuffer, offset + repl.length, offset + options.length);
    }

    return newBuffer;
};

/**
 * Insert a new byte sequence into the buffer.
 *
 * @param {buffer} buf - source buffer
 * @param {string|buffer} bytes - byte sequence to insert
 * @param {number} offset - offset where to insert the byte sequence to
 *
 * @return {buffer} new modified buffer with the inserted byte sequence
 */
ILXBufferUtil.prototype.insert = function(buffer, bytes, offset)
{
    var newBuffer;

    if (buffer === undefined) {
        throw new Error("A buffer must be specified");
    }

    if (bytes === undefined) {
        throw new Error("An insert byte sequence must be specified");
    }

    if (offset === undefined) {
        throw new Error("An offset must be specified");
    }

    if ((offset > buffer.length) || (offset < 0)) {
        throw new Error("The offset is out of range (0 - " +
                        buffer.length + ")");
    }

    newBuffer = new Buffer(buffer.length + bytes.length);
    if (offset > 0) {
        buffer.copy(newBuffer, 0, 0, offset);
    }

    if (Buffer.isBuffer(bytes)) {
        bytes.copy(newBuffer, offset);
    }
    else {
        newBuffer.write(bytes, offset, bytes.length);
    }

    if (offset < buffer.length) {
        buffer.copy(newBuffer, offset + bytes.length, offset);
    }

    return newBuffer;
};

/**
 * Append a byte sequence, i.e., insert it at the end
 *
 * @param {buffer} buf - source buffer
 * @param {string|buffer} bytes - byte sequence to append
 *
 * @return {buffer} new buffer with the appended byte sequence
 */
ILXBufferUtil.prototype.append = function(buffer, bytes)
{
    var newBuffer;

    if (buffer === undefined) {
        throw new Error("A buffer must be specified");
    }

    if (bytes === undefined) {
        throw new Error("An insert byte sequence must be specified");
    }

    if (Buffer.isBuffer(bytes)) {
        return Buffer.concat([buffer, bytes]);
    }
    else {
        newBuffer = new Buffer(buffer.length + bytes.length);
        buffer.copy(newBuffer);
        newBuffer.write(bytes, buffer.length, bytes.length);
        return newBuffer;
    }
};

/**
 * Erase some portion of a buffer
 *
 * @param {buffer} buf - source buffer
 * @param {number} offset - offset of the byte sequence to erase
 * @param {number} len - length of the byte sequence to erase
 *
 * @return: {buffer} new buffer with the erased chunk
 */
ILXBufferUtil.prototype.erase = function(buffer, offset, len)
{
    var newBuffer;

    if (buffer === undefined) {
        throw new Error("A buffer must be specified");
    }
    if (offset === undefined) {
        throw new Error("An offset must be specific");
    }
    if (len === undefined) {
        throw new Error("A len must be specified");
    }

    if ((offset > (buffer.length - 1)) || offset < 0) {
        throw new Error("The offset is out of range (0 - " +
                        (buffer.length - 1) + ")");
    }
    len = Math.min(len, buffer.length - offset);

    newBuffer = new Buffer(buffer.length - len);
    if (offset > 0) {
        buffer.copy(newBuffer, 0, 0, offset);
    }
    if ((offset + len) < buffer.length) {
        buffer.copy(newBuffer, offset, offset + len);
    }

    return newBuffer;
};

module.exports = new ILXBufferUtil();
